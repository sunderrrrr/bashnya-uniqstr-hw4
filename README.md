БАШНЯ | Backend на Go | Домашнее задание №2
Как работать с данным репозиторием
Создать репозиторий на основе данного шаблона (Нажать зелёную кнопку Use this template -> Create a new repository. Имя репозитория можно задать произвольно)
Создать ветку develop
Выполнить задание. Всё решение необходимо расположить в корне репозитория
Создать Pull Request (PR) на слияние ветки develop в ветку main
Внимание! Это ДЗ имеет систему автоматического тестирования. Отправлять решене на проверку необходимо только после успешного прохождения автоматического тестирования!
Мерджить ветки можно только после одобрения ревьюера!
Задание
Реализовать утилиту для поиска уникальных строк. Сама утилита имеет набор параметров, которые необходимо поддержать.

Параметры
-с - подсчитать количество встречаний строки во входных данных. Вывести это число перед строкой отделив пробелом.

-d - вывести только те строки, которые повторились во входных данных.

-u - вывести только те строки, которые не повторились во входных данных.

-f num_fields - не учитывать первые num_fields полей в строке. Полем в строке является непустой набор символов отделённый пробелом.

-s num_chars - не учитывать первые num_chars символов в строке. При использовании вместе с параметром -f учитываются первые символы после num_fields полей (не учитывая пробел-разделитель после последнего поля).

-i - не учитывать регистр букв.

Использование
uniq [-c | -d | -u] [-i] [-f num] [-s chars] [input_file [output_file]]

Все параметры опциональны. Поведения утилиты без параметров -- простой вывод уникальных строк из входных данных.

Параметры c, d, u взаимозаменяемы. Необходимо учитывать, что параллельно эти параметры не имеют никакого смысла. При передаче одного вместе с другим нужно отобразить пользователю правильное использование утилиты

Если не передан input_file, то входным потоком считать stdin

Если не передан output_file, то выходным потоком считать stdout

Пример работы
Без параметров
С параметром input_file
С параметрами input_file и output_file
С параметром -c
С параметром -d
С параметром -u
С параметром -i
С параметром -f num
С параметром -s num
Unit-тесты
Необходимо протестировать поведение написанной функциональности с различными параметрами. Для тестирования нужно написать unit-тесты на эту функциональность. Тесты нужны как для успешных случаев, так и для неуспешных. Примеры тестов можно посмотреть здесь.

Автоматическое тестирование
Для автоматической проверки написанного решения используется сервис GitHub Actions.

После создания Pull Request-а в ветку main запускается автоматическое тестирование, включающее в себя следующие этипы:

Сборка проекта
Запуск линтера
Запуск unit-тестов, написанных в рамках решения
Запуск приёмочных тестов
Если все проверки проходят успешно, на странице PR-а должна появиться зелёная галочка и надпись "All checks have passed".

Материалы в помощь
https://habr.ru/post/306914/ - пакет io

https://golang.org/pkg/sort/

https://golang.org/pkg/io/

https://golang.org/pkg/io/ioutil/

https://godoc.org/flag - пакет для флагов

https://godoc.org/github.com/stretchr/testify - удобный набор пакетов для тестирования

https://golang.org/pkg/bufio/#Scanner - удобный способ прочитать линии из потока данных

Best practices
Уникализация может понадобиться не только как утилита, но и как часть более крупной логики. Для этого саму функцию уникализации можно вынести в отдельный пакет. Поскольку более крупная логика не всегда связана с чтением аргументов и данных из файла или stdin, то на вход этой функции нужно передавать слайс строк и аргументы.

Как файл, так и stdin удовлетворяет интерфейсу io.Reader. Поэтому логику по чтению можно сделать универсальной. Аналогично и с записью - io.Writer

Множество параметров, которые вдобавок и опциональны, лучше передавать структурой (например Options). Так проще расширять функциональность, а внешнему пользователю функции (не всей утилиты) будет проще передать правильные аргументы внутрь.

Для написания однотипных тестовых случаев используется табличное тестирование. Получается, что можно написать две функции тестов: успешные тестовые случаи и неуспешные тестовые случаи.

Для сравнения ожидаемого и действительного можно использовать пакет require. Кроме простых сравнений на равенство пакет предоставляет много других ассертов.

Тесты не должны зависеть от внешних ресурсов. Не нужно читать файлы внутри теста. Так же не нужно тестировать передачу параметров при вызове утилиты. Никакого внешнего взаимодействия. Тестирование функции должно быть построено на том, что мы передаём некоторые входные данные в функцию и сравниваем ответ функции с ожидаемыми выходными данными.